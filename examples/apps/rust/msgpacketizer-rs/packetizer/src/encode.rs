use crate::common::{crc8_smbus, to_hex_str};
use cobs;
use log::debug;

pub fn encode(index: u8, mut data: Vec<u8>) -> Vec<u8> {
    debug!("Encode input: {index}, {:?}", data);
    let checksum = crc8_smbus(&data);
    data.push(checksum);
    data.insert(0, index);
    let mut encoded = cobs::encode_vec(&data);
    encoded.push(0);
    debug!("Encoded: {}", to_hex_str(&encoded));
    encoded
}

#[cfg(test)]
mod tests {
    use super::*;
    use env_logger;
    use std::sync::Once;
    static INIT: Once = Once::new();

    fn setup() {
        INIT.call_once(|| {
            std::env::set_var("RUST_LOG", "debug");
            env_logger::builder().is_test(true).try_init().unwrap();
        });
    }

    #[test]
    fn test_encode_simple() {
        setup();
        let input = vec![
            0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76,
            0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x5b, 0x73,
            0x65, 0x63, 0x5d,
        ];
        let encoded = encode(0x01, input);
        assert_eq!(
            encoded,
            vec![
                0x22, 0x01, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f,
                0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                0x5b, 0x73, 0x65, 0x63, 0x5d, 0x43, 0x00
            ]
        );
    }

    #[test]
    fn test_encode_arr() {
        setup();
        let input = vec![
            0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x00, 0x01, 0xe2, 0x40, 0x7b,
        ];
        let encoded = encode(0x11, input);
        assert_eq!(
            encoded,
            vec![
                0x09, 0x11, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x06, 0x01, 0xe2, 0x40, 0x7b,
                0xa3, 0x00
            ]
        );
    }

    #[test]
    fn test_encode_map() {
        setup();
        let input = vec![
            0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6,
            0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65,
            0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b,
        ];
        let encoded = encode(0x21, input);
        assert_eq!(
            encoded,
            vec![
                0x17, 0x21, 0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd,
                0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7,
                0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b, 0xeb, 0x00
            ]
        );
    }

    #[test]
    fn test_encode_custom() {
        setup();
        let input = vec![
            0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24,
            0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37,
            0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6, 0x6d, 0x69,
            0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c,
            0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64,
            0x73, 0x7b,
        ];
        let encoded = encode(0x31, input);
        assert_eq!(
            encoded,
            vec![
                0x3d, 0x31, 0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40,
                0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35,
                0x36, 0x37, 0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6,
                0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69,
                0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f,
                0x6e, 0x64, 0x73, 0x7b, 0x5b, 0x00
            ]
        );
    }
}
