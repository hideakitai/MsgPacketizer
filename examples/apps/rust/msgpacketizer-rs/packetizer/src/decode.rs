use crate::common::{crc8_smbus, to_hex_str, Message, MessageRef};
use cobs;
use log::{debug, error};

pub fn decode(input: &[u8]) -> Option<Message> {
    debug!("Decode input: {}", to_hex_str(input));

    let result = cobs::decode_vec(&input);
    let mut data = if let Ok(data) = result {
        data
    } else {
        error!("Failed to decode COBS");
        return None;
    };
    debug!("Decoded len: {}", data.len());

    if data.len() < 3 {
        error!("Decoded length is too short: {}", input.len());
        return None;
    }

    let index = data.remove(0);
    let checksum_recv = data.pop().unwrap();
    let checksum_calc = crc8_smbus(&data);
    if checksum_recv != checksum_calc {
        error!("Checksum mismatch: {checksum_recv} != {checksum_calc}");
        return None;
    }
    debug!(
        "COBS decoded to index: {index}, data: {}",
        to_hex_str(&data)
    );

    Some(Message { index, data })
}

pub fn decode_in_place(mut input: &mut [u8]) -> Option<(MessageRef, usize)> {
    debug!("Decode input: {}", to_hex_str(input));

    let result = cobs::decode_in_place_report(&mut input);
    let report = if let Ok(report) = result {
        report
    } else {
        error!("Failed to decode COBS");
        return None;
    };
    debug!("Decoded src {} -> dst {}", report.src_used, report.dst_used);

    if report.dst_used < 3 {
        error!("Decoded length is too short: {}", report.dst_used);
        return None;
    }

    let checksum_recv = input[report.dst_used - 1];
    let checksum_calc = crc8_smbus(&input[1..report.dst_used - 1]);
    if checksum_recv != checksum_calc {
        error!("Checksum mismatch: {checksum_recv} != {checksum_calc}");
        return None;
    }

    let index = input[0];
    let data = &input[1..report.dst_used - 1];
    debug!("COBS decoded to index: {index}, data: {}", to_hex_str(data));

    let offset = if input[report.src_used] == 0 { 1 } else { 0 };
    Some((MessageRef { index, data }, report.src_used + offset))
}

#[cfg(test)]
mod tests {
    use super::*;
    use env_logger;
    use std::sync::Once;
    static INIT: Once = Once::new();

    fn setup() {
        INIT.call_once(|| {
            std::env::set_var("RUST_LOG", "debug");
            env_logger::builder().is_test(true).try_init().unwrap();
        });
    }

    #[test]
    fn test_decode_simple() {
        setup();
        let input = vec![
            0x22, 0x01, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f,
            0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
            0x5b, 0x73, 0x65, 0x63, 0x5d, 0x43, 0x00,
        ];
        let msg = decode(&input).unwrap();
        assert_eq!(msg.index, 0x01);
        assert_eq!(
            msg.data,
            vec![
                0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76,
                0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x5b, 0x73,
                0x65, 0x63, 0x5d,
            ]
        );
    }
    #[test]
    fn test_decode_in_place_simple() {
        setup();
        let mut input = vec![
            0x22, 0x01, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f,
            0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
            0x5b, 0x73, 0x65, 0x63, 0x5d, 0x43, 0x00,
        ];
        let (msg, used) = decode_in_place(&mut input).unwrap();
        assert_eq!(msg.index, 0x01);
        assert_eq!(
            msg.data,
            vec![
                0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76,
                0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x5b, 0x73,
                0x65, 0x63, 0x5d,
            ]
        );
        assert_eq!(used, input.len());
    }

    #[test]
    fn test_decode_arr() {
        setup();
        let input = vec![
            0x09, 0x11, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x06, 0x01, 0xe2, 0x40, 0x7b,
            0xa3, 0x00,
        ];
        let msg = decode(&input).unwrap();
        assert_eq!(msg.index, 0x11);
        assert_eq!(
            msg.data,
            vec![0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x00, 0x01, 0xe2, 0x40, 0x7b,]
        );
    }

    #[test]
    fn test_decode_in_place_arr() {
        setup();
        let mut input = vec![
            0x09, 0x11, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x06, 0x01, 0xe2, 0x40, 0x7b,
            0xa3, 0x00,
        ];
        let (msg, used) = decode_in_place(&mut input).unwrap();
        assert_eq!(msg.index, 0x11);
        assert_eq!(
            msg.data,
            vec![0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xce, 0x00, 0x01, 0xe2, 0x40, 0x7b,]
        );
        assert_eq!(used, input.len());
    }

    #[test]
    fn test_decode_map() {
        setup();
        let input = vec![
            0x17, 0x21, 0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd,
            0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7,
            0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b, 0xeb, 0x00,
        ];
        let msg = decode(&input).unwrap();
        assert_eq!(msg.index, 0x21);
        assert_eq!(
            msg.data,
            vec![
                0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6,
                0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65,
                0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b,
            ]
        );
    }

    #[test]
    fn test_decode_in_place_map() {
        setup();
        let mut input = vec![
            0x17, 0x21, 0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd,
            0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7,
            0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b, 0xeb, 0x00,
        ];
        let (msg, used) = decode_in_place(&mut input).unwrap();
        assert_eq!(msg.index, 0x21);
        assert_eq!(
            msg.data,
            vec![
                0x83, 0xa6, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6,
                0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65,
                0x63, 0x6f, 0x6e, 0x64, 0x73, 0x7b,
            ]
        );
        assert_eq!(used, input.len());
    }

    #[test]
    fn test_decode_custom() {
        setup();
        let input = vec![
            0x3d, 0x31, 0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40,
            0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35,
            0x36, 0x37, 0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6,
            0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69,
            0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f,
            0x6e, 0x64, 0x73, 0x7b, 0x5b, 0x00,
        ];
        let msg = decode(&input).unwrap();
        assert_eq!(msg.index, 0x31);
        assert_eq!(
            msg.data,
            vec![
                0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24,
                0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37,
                0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6, 0x6d, 0x69,
                0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c,
                0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64,
                0x73, 0x7b,
            ]
        );
    }

    #[test]
    fn test_decode_in_place_custom() {
        setup();
        let mut input = vec![
            0x3d, 0x31, 0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40,
            0xfe, 0x24, 0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35,
            0x36, 0x37, 0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6,
            0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69,
            0x6c, 0x6c, 0x69, 0x73, 0xce, 0x0e, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f,
            0x6e, 0x64, 0x73, 0x7b, 0x5b, 0x00,
        ];
        let (msg, used) = decode_in_place(&mut input).unwrap();
        assert_eq!(msg.index, 0x31);
        assert_eq!(
            msg.data,
            vec![
                0x82, 0xa2, 0x6b, 0x61, 0x93, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xcb, 0x40, 0xfe, 0x24,
                0x0c, 0x9f, 0xbe, 0x76, 0xc9, 0xaf, 0x31, 0x32, 0x33, 0x2e, 0x34, 0x35, 0x36, 0x37,
                0x38, 0x39, 0x5b, 0x73, 0x65, 0x63, 0x5d, 0xa2, 0x6b, 0x6d, 0x83, 0xa6, 0x6d, 0x69,
                0x63, 0x72, 0x6f, 0x73, 0xce, 0x07, 0x5b, 0xcd, 0x15, 0xa6, 0x6d, 0x69, 0x6c, 0x6c,
                0x69, 0x73, 0xce, 0x00, 0x01, 0xe2, 0x40, 0xa7, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64,
                0x73, 0x7b,
            ]
        );
        assert_eq!(used, input.len());
    }
}
